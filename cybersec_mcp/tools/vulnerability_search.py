"""
Simple vulnerability search tool using NIST NVD API with Pydantic models.
"""

import logging
from typing import List, Optional
from pydantic import BaseModel, ConfigDict
from langchain_core.tools import BaseTool
import httpx
from config.settings import settings
import asyncio
from datetime import datetime, timezone, timedelta

logger = logging.getLogger(__name__)


class CVEResult(BaseModel):
    """Individual CVE result"""
    cve_id: str
    description: str
    severity: str = "UNKNOWN"
    cvss_score: float = 0.0
    published_date: str


class VulnerabilitySearchResponse(BaseModel):
    """Response model for vulnerability search"""
    status: str = "success"
    query: str
    total_results: int
    results: List[CVEResult]
    error: Optional[str] = None


class VulnerabilitySearchTool(BaseTool):
    """Tool for searching vulnerability databases like NIST NVD"""
    name: str = "vulnerability_search"
    description: str = "Search for vulnerabilities by CVE ID, product name, or technology."
    api_key: Optional[str] = settings.nist_api_key
    base_url: str = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    client: httpx.AsyncClient = None

    model_config = ConfigDict(extra="allow", arbitrary_types_allowed=True)

    def __init__(self, **data):
        super().__init__(**data)
        """Initialize NIST NVD client"""
        # API key is optional for NVD but recommended for higher rate limits
        if self.api_key:
            self.api_key = settings.get_secret("nist_api_key")
        else:
            logger.warning("NIST_API_KEY not set, using anonymous access (rate limited)")
        self.client = httpx.AsyncClient(timeout=20.0)

    def _run(
        self,
        query: str,
        severity_filter: Optional[List[str]] = None,
        include_patched: bool = False,
        date_range: Optional[str] = None,
        limit: int = 10,
        exact_phrase: bool = False,
    ) -> VulnerabilitySearchResponse:
        """Search for vulnerabilities in NIST NVD."""
        return asyncio.run(
            self.search(
                query,
                severity_filter,
                include_patched,
                date_range,
                limit,
                exact_phrase,
            )
        )

    async def _arun(
        self,
        query: str,
        severity_filter: Optional[List[str]] = None,
        include_patched: bool = False,
        date_range: Optional[str] = None,
        limit: int = 10,
        exact_phrase: bool = False,
    ) -> VulnerabilitySearchResponse:
        """Search for vulnerabilities in NIST NVD."""
        return await self.search(
            query,
            severity_filter,
            include_patched,
            date_range,
            limit,
            exact_phrase,
        )

    async def search(
        self,
        query: str,
        severity_filter: Optional[List[str]] = None,
        include_patched: bool = False,
        date_range: Optional[str] = None,
        limit: int = 10,
        exact_phrase: bool = False,
    ) -> VulnerabilitySearchResponse:
        """
        Search for vulnerabilities in NIST NVD.
        
        Args:
            query: Search query (product name or CVE ID)
            severity_filter: Filter by severity ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
            include_patched: Include vulnerabilities that have been patched
            date_range: Filter by date ('week', 'month', 'year')
            limit: Maximum results
            exact_phrase: If True, search for the exact phrase; if False, search for individual words (AND logic)
            
        Returns:
            VulnerabilitySearchResponse with typed results
        """
        try:
            # Build request
            params = {"resultsPerPage": min(limit, 20)}
            headers = {}
            
            if self.api_key:
                headers["apiKey"] = self.api_key
            
            # Check if searching for specific CVE
            if query.upper().startswith("CVE-"):
                params["cveId"] = query.upper()
            else:
                # Apply other filters only for keyword searches
                params["keywordSearch"] = query
                
                # Handle exact phrase matching
                if exact_phrase and " " in query:
                    # For exact phrase matching, add the flag parameter without a value
                    params["keywordExactMatch"] = ""
                
                # Exclude rejected CVEs by default
                params["noRejected"] = ""

                # Handle date range
                if date_range:
                    try:
                        end_date = datetime.now(timezone.utc)
                        if date_range == "week":
                            start_date = end_date - timedelta(days=7)
                        elif date_range == "month":
                            start_date = end_date - timedelta(days=30)
                        elif date_range == "year":
                            start_date = end_date - timedelta(days=365)
                        else:
                            # Default to month if invalid range
                            start_date = end_date - timedelta(days=30)

                        params["pubStartDate"] = start_date.isoformat()
                        params["pubEndDate"] = end_date.isoformat()
                    except (ValueError, TypeError) as e:
                        logger.warning(f"Invalid date_range value: {date_range}. Error: {e}")

            logger.info(f"NIST NVD API request: {self.base_url} with params: {params}")

            # Make request
            response = await self.client.get(self.base_url, params=params, headers=headers)
            
            if response.status_code != 200:
                error_msg = f"API error: {response.status_code}"
                if response.status_code == 403:
                    error_msg += " - Forbidden. Check your API key or rate limits."
                elif response.status_code == 429:
                    error_msg += " - Rate limit exceeded. Try again later."
                
                return VulnerabilitySearchResponse(
                    status="error",
                    query=query,
                    total_results=0,
                    results=[],
                    error=error_msg
                )
            
            # Parse results
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])
            
            logger.info(f"NIST API returned {len(vulnerabilities)} vulnerabilities")
            
            cve_results = []
            for vuln in vulnerabilities:
                cve = vuln.get("cve", {})
                
                # Extract basic info
                cve_id = cve.get("id", "")
                descriptions = cve.get("descriptions", [])
                description = ""
                
                # Find English description
                for desc in descriptions:
                    if desc.get("lang") == "en":
                        description = desc.get("value", "")
                        break
                
                # If no English description found, use the first one
                if not description and descriptions:
                    description = descriptions[0].get("value", "")
                
                # Truncate long descriptions
                if len(description) > 200:
                    description = description[:200] + "..."
                
                # Get CVSS score and severity
                severity, cvss_score = self._extract_cvss(cve.get("metrics", {}))
                
                # Apply severity filter
                if severity_filter and severity not in severity_filter:
                    continue
                
                # Create CVE result
                cve_result = CVEResult(
                    cve_id=cve_id,
                    description=description,
                    severity=severity,
                    cvss_score=cvss_score,
                    published_date=cve.get("published", "")[:10]
                )
                cve_results.append(cve_result)
            
            return VulnerabilitySearchResponse(
                query=query,
                total_results=len(cve_results),
                results=cve_results
            )
                
        except Exception as e:
            logger.error(f"Search error: {str(e)}")
            return VulnerabilitySearchResponse(
                status="error",
                query=query,
                total_results=0,
                results=[],
                error=str(e)
            )
    
    def _extract_cvss(self, metrics: dict) -> tuple[str, float]:
        """Extract CVSS score and severity from metrics"""
        # Try CVSS v3.1 first (most recent)
        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
            return (
                cvss_data.get("baseSeverity", "UNKNOWN"),
                cvss_data.get("baseScore", 0.0)
            )
        
        # Try CVSS v3.0
        if "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
            return (
                cvss_data.get("baseSeverity", "UNKNOWN"),
                cvss_data.get("baseScore", 0.0)
            )
        
        # Try CVSS v2 as fallback
        if "cvssMetricV2" in metrics:
            cvss_data = metrics["cvssMetricV2"][0]
            return (
                cvss_data.get("baseSeverity", "UNKNOWN"),
                cvss_data.get("cvssData", {}).get("baseScore", 0.0)
            )
        
        return "UNKNOWN", 0.0